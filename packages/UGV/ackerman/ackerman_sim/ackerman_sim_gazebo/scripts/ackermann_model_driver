#!/usr/bin/env python3

"""
Subscribed Topics:
    cmd_vel (ackermann_msgs/AckermannDrive)
        Ackermann command. It contains the vehicle's desired speed and steering
        angle.
    /softestop (std_msgs/Bool)
        Estop command. Abruptly stops tractor when estopped.
    /state_controller/cmd_activate (std_msgs/Bool)
        Activate command. Sends stop command to tractor upon disactivation.
Published Topics:
    <left steering controller name>/command (std_msgs/Float64)
        Command for the left steering controller.
    <right steering controller name>/command (std_msgs/Float64)
        Command for the right steering controller.
    <left front axle controller name>/command (std_msgs/Float64)
        Command for the left front axle controller.
    <right front axle controller name>/command (std_msgs/Float64)
        Command for the right front axle controller.
    <left rear axle controller name>/command (std_msgs/Float64)
        Command for the left rear axle controller.
    <right rear axle controller name>/command (std_msgs/Float64)
        Command for the right rear axle controller.
    <shock absorber controller name>/command (std_msgs/Float64)

"""

import math
import numpy
import threading
from math import pi

import rospy

from ackermann_msgs.msg import AckermannDrive
from std_msgs.msg import Float64
from std_msgs.msg import Bool
from controller_manager_msgs.srv import ListControllers


class _AckermannCtrlr(object):

    def __init__(self):
        """Initialize this _AckermannCtrlr."""

        rospy.init_node("ackermann_controller")
        # Parameters
        self._tractor_delay               = rospy.get_param("~tractor_delay")                        # 0：无延时的角度控制   其他是角度 和 运动速度
        self._max_acceleration            = rospy.get_param("~max_acceleration")                     # 车体运动的最大角速度
        self._max_steering_angle_velocity = rospy.get_param("~max_steering_angle_velocity")          # 最大方向盘速度
        self._max_steering_angle_scare    = rospy.get_param("~max_steering_angle_scare",25.0)
        self._steering_control_mode       = rospy.get_param("~steering_control_mode", 0)
        # Wheels
        (left_steer_link_name, left_steer_ctrlr_name,
         left_front_axle_ctrlr_name, self._left_front_inv_circ)   = self._get_front_wheel_params("left")

        (right_steer_link_name, right_steer_ctrlr_name,
         right_front_axle_ctrlr_name, self._right_front_inv_circ) = self._get_front_wheel_params("right")

        (left_rear_link_name, left_rear_axle_ctrlr_name,
         self._left_rear_inv_circ)                                = self._get_rear_wheel_params("left")

        (self._right_rear_link_name, right_rear_axle_ctrlr_name,
         self._right_rear_inv_circ)                               = self._get_rear_wheel_params("right")

        list_ctrlrs = rospy.ServiceProxy("controller_manager/list_controllers", ListControllers)
        list_ctrlrs.wait_for_service()

        # Publishing frequency
        try:
            pub_freq = float(rospy.get_param("~publishing_frequency", self._DEF_PUB_FREQ))
            if pub_freq <= 0.0:
                raise ValueError()
        except:
            rospy.logwarn("The specified publishing frequency is invalid. "
                          "The default frequency will be used instead.")
            pub_freq = self._DEF_PUB_FREQ
        self._sleep_timer = rospy.Rate(pub_freq)

        # _last_cmd_time is the time at which the most recent Ackermann
        # driving command was received.
        self._last_cmd_time = rospy.get_time()

        # _ackermann_cmd_lock is used to control access to _steer_ang,
        # _steer_ang_vel, _speed, and _accel.
        self._ackermann_cmd_lock  = threading.Lock()
        self._steer_ang           = 0.0          # Steering angle
        self._steer_ang_vel       = 0.0          # Steering angle    velocity
        self._speed               = 0.0
        self._accel               = 0.0          # Acceleration

        self._last_steer_ang      = 0.0          # Last     steering angle
        self._theta_left          = 0.0          # Left     steering joint angle
        self._theta_right         = 0.0          # Right    steering joint angle

        self._last_speed          = 0.0
        self._last_accel_limit    = 0.0          # Last     acceleration limit
        
        self._left_front_ang_vel  = 0.0
        self._right_front_ang_vel = 0.0
        self._left_rear_ang_vel   = 0.0
        self._right_rear_ang_vel  = 0.0
        self._joint_dist_div_2    = 1.43124 / 2            #  前两个转向轮距离的一半
        self._wheelbase           = 2.054                  #  车辆轴距
        self._inv_wheelbase       = 1 / self._wheelbase    #  轴距的倒数
        self._wheelbase_sqr       = self._wheelbase ** 2   #  轴距的平方
        self._estop               = False
        

        # Publishers and subscribers

        self._left_steer_cmd_pub  = _create_cmd_pub(list_ctrlrs, left_steer_ctrlr_name)
        self._right_steer_cmd_pub = _create_cmd_pub(list_ctrlrs, right_steer_ctrlr_name)

        self._left_front_axle_cmd_pub  = \
            _create_axle_cmd_pub(list_ctrlrs, left_front_axle_ctrlr_name)
        self._right_front_axle_cmd_pub = \
            _create_axle_cmd_pub(list_ctrlrs, right_front_axle_ctrlr_name)
        self._left_rear_axle_cmd_pub   = \
            _create_axle_cmd_pub(list_ctrlrs, left_rear_axle_ctrlr_name)
        self._right_rear_axle_cmd_pub  = \
            _create_axle_cmd_pub(list_ctrlrs, right_rear_axle_ctrlr_name)

        self._ackermann_cmd_sub = \
            rospy.Subscriber("/cmd_vel", AckermannDrive, #Changed from ackermann_cmd
                             self._ackermann_cmd_cb, queue_size=1)
        self._softestop_sub = \
            rospy.Subscriber("/softestop", Bool,
                             self._softestop_cb, queue_size=1)

    def spin(self):
        """Control the vehicle."""
        last_time = rospy.get_time()

        while not rospy.is_shutdown():
            t = rospy.get_time()
            delta_t = t - last_time
            last_time = t

            if delta_t > 0.0:
                with self._ackermann_cmd_lock:
                    if self._estop == True: # Abruptly stop when estopped (simulate engine shut off)
                        steer_ang = 0
                        steer_ang_vel = 10.0
                        speed = 0
                        accel = 5.0
                    else: # If not estopped or disactivated, run tractor
                        steer_ang = self._steer_ang*(3.14/180) # convert from degrees to rad
                        steer_ang_vel = self._steer_ang_vel
                        speed = self._speed
                        accel = self._accel
                steer_ang_changed, center_y = self._ctrl_steering(steer_ang, steer_ang_vel, delta_t)
                self._ctrl_axles(speed, accel, delta_t, steer_ang_changed,
                                 center_y)

            # Publish the steering and axle joint commands.
            self._left_steer_cmd_pub.publish(self._theta_left)
            self._right_steer_cmd_pub.publish(self._theta_right)
            if self._left_front_axle_cmd_pub:
                self._left_front_axle_cmd_pub.publish(self._left_front_ang_vel)
            if self._right_front_axle_cmd_pub:
                self._right_front_axle_cmd_pub.\
                    publish(self._right_front_ang_vel)
            if self._left_rear_axle_cmd_pub:
                self._left_rear_axle_cmd_pub.publish(self._left_rear_ang_vel)
            if self._right_rear_axle_cmd_pub:
                self._right_rear_axle_cmd_pub.publish(self._right_rear_ang_vel)

            self._sleep_timer.sleep()

    def _ackermann_cmd_cb(self, ackermann_cmd):
        self._last_cmd_time = rospy.get_time()
        with self._ackermann_cmd_lock:
            if(self._steering_control_mode == 0):
                if (self._tractor_delay == 0):
                    self._steer_ang = ackermann_cmd.steering_angle
                    self._steer_ang_vel = self._max_steering_angle_velocity
                    self._speed = ackermann_cmd.speed
                    self._accel = self._max_acceleration
                else:
                    self._steer_ang = ackermann_cmd.steering_angle
                    self._steer_ang_vel = ackermann_cmd.steering_angle_velocity
                    self._speed = ackermann_cmd.speed
                    self._accel = ackermann_cmd.acceleration   

                if(abs(self._steer_ang) > self._max_steering_angle_scare):
                    if(self._steer_ang > 0):
                        self._steer_ang = self._max_steering_angle_scare
                    else:
                        self._steer_ang = -self._max_steering_angle_scare

            elif(self._steering_control_mode == 1):
                self._steer_ang_vel = ackermann_cmd.steering_angle_velocity
                self._speed = ackermann_cmd.speed
                self._accel = ackermann_cmd.acceleration
                if(ackermann_cmd.steering_angle_velocity > 0):
                    self._steer_ang = self._max_steering_angle_scare
                else:
                    self._steer_ang = -self._max_steering_angle_scare

    def _softestop_cb(self, softestop):
        self._estop = softestop.data

    def _get_front_wheel_params(self, side):
        # Get front wheel parameters. Return a tuple containing the steering
        # link name, steering controller name, axle controller name (or None),
        # and inverse of the circumference.

        prefix = "~" + side + "_front_wheel/"
        steer_link_name = rospy.get_param(prefix + "steering_link_name", "front_" + side + "_wheel")
        steer_ctrlr_name = rospy.get_param(prefix + "steering_controller_name", side + "_steering_ctrlr")   # left_steering_ctrlr
        axle_ctrlr_name, inv_circ = self._get_common_wheel_params(prefix)
        return steer_link_name, steer_ctrlr_name, axle_ctrlr_name, inv_circ

    def _get_rear_wheel_params(self, side):
        # Get rear wheel parameters. Return a tuple containing the link name,
        # axle controller name, and inverse of the circumference.

        prefix = "~" + side + "_rear_wheel/"
        link_name = rospy.get_param(prefix + "link_name", "rear_" + side + "_wheel")
        axle_ctrlr_name, inv_circ = self._get_common_wheel_params(prefix)
        
        return link_name, axle_ctrlr_name, inv_circ

    def _get_common_wheel_params(self, prefix):
        # Get parameters used by the front and rear wheels. Return a tuple
        # containing the axle controller name (or None) and the inverse of the
        # circumference.

        axle_ctrlr_name = rospy.get_param(prefix + "axle_controller_name",None)

        try:
            dia = float(rospy.get_param(prefix + "diameter", self._DEF_WHEEL_DIA))   # 车轮直径
            if dia <= 0.0:
                raise ValueError()
        except:
            rospy.logwarn("The specified wheel diameter is invalid. "
                          "The default diameter will be used instead.")
            dia = self._DEF_WHEEL_DIA

        return axle_ctrlr_name, 1 / (pi * dia)

    def _get_link_pos(self, tfl, link):
        # Return the position of the specified link, relative to the right
        # rear wheel link.
        while True:
            try:
                trans, not_used = \
                    tfl.lookupTransform(self._right_rear_link_name, link,
                                        rospy.Time(0))
                return numpy.array(trans)
            except:
                pass

    def _ctrl_steering(self, steer_ang, steer_ang_vel_limit, delta_t):
        # Control the steering joints.
        # Compute theta, the virtual front wheel's desired steering angle.
        if steer_ang_vel_limit > 0.0:
            # Limit the steering velocity.
            ang_vel = (steer_ang - self._last_steer_ang) / delta_t
            ang_vel = max(-steer_ang_vel_limit,
                           min(ang_vel, steer_ang_vel_limit))
            theta = self._last_steer_ang + ang_vel * delta_t
        else:
            theta = steer_ang

        # Compute the desired steering angles for the left and right front
        # wheels.
        center_y = self._wheelbase * math.tan((pi / 2) - theta)
        steer_ang_changed = theta != self._last_steer_ang
        if steer_ang_changed:
            self._last_steer_ang = theta
            self._theta_left = \
                _get_steer_ang(math.atan(self._inv_wheelbase *
                                         (center_y - self._joint_dist_div_2)))
            self._theta_right = \
                _get_steer_ang(math.atan(self._inv_wheelbase *
                                         (center_y + self._joint_dist_div_2)))

        return steer_ang_changed, center_y

    def _ctrl_axles(self, speed, accel_limit, delta_t, steer_ang_changed,
                    center_y):
        # Control the axle joints.
        # Compute veh_speed, the vehicle's desired speed.
        if accel_limit > 0.0:
            # Limit the vehicle's acceleration.
            self._last_accel_limit = accel_limit
            accel = (speed - self._last_speed) / delta_t
            accel = max(-accel_limit, min(accel, accel_limit))
            veh_speed = self._last_speed + accel * delta_t
        else:
            self._last_accel_limit = accel_limit
            veh_speed = speed

        # Compute the desired angular velocities of the wheels.
        if veh_speed != self._last_speed or steer_ang_changed:
            self._last_speed = veh_speed
            left_dist = center_y - self._joint_dist_div_2
            right_dist = center_y + self._joint_dist_div_2

            # Front
            gain = (2 * pi) * veh_speed / abs(center_y)
            r = math.sqrt(left_dist ** 2 + self._wheelbase_sqr)
            self._left_front_ang_vel = gain * r * self._left_front_inv_circ
            r = math.sqrt(right_dist ** 2 + self._wheelbase_sqr)
            self._right_front_ang_vel = gain * r * self._right_front_inv_circ
            # Rear
            gain = (2 * pi) * veh_speed / center_y
            self._left_rear_ang_vel = \
                gain * left_dist * self._left_rear_inv_circ
            self._right_rear_ang_vel = \
                gain * right_dist * self._right_rear_inv_circ

    _DEF_WHEEL_DIA = 0.5    # Default wheel diameter. Unit         : meter.
    _DEF_EQ_POS    = 0.0       # Default equilibrium position. Unit: meter.
    _DEF_PUB_FREQ  = 30.0    # Default publishing frequency. Unit  : hertz.
# end _AckermannCtrlr

def _wait_for_ctrlr(list_ctrlrs, ctrlr_name):
    # Wait for the specified controller to be in the "running" state.
    # Commands can be lost if they are published before their controller is
    # running, even if a latched publisher is used.

    while True:
        response = list_ctrlrs()
        for ctrlr in response.controller:
            if ctrlr.name == ctrlr_name:
                if ctrlr.state == "running":
                    return
                rospy.sleep(0.1)
                break


def _create_axle_cmd_pub(list_ctrlrs, axle_ctrlr_name):
    # Create an axle command publisher.
    if not axle_ctrlr_name:
        return None
    return _create_cmd_pub(list_ctrlrs, axle_ctrlr_name)


def _create_cmd_pub(list_ctrlrs, ctrlr_name):
    # Create a command publisher.
    _wait_for_ctrlr(list_ctrlrs, ctrlr_name)
    return rospy.Publisher(ctrlr_name + "/command", Float64, queue_size=1)


def _get_steer_ang(phi):
    # Return the desired steering angle for a front wheel.
    if phi >= 0.0:
        return (pi / 2) - phi
    return (-pi / 2) - phi

# main
if __name__ == "__main__":
    ctrlr = _AckermannCtrlr()
    ctrlr.spin()

